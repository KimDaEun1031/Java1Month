package test;

public class 쉬프트연산자 {

	public static void main(String[] args) {
		int a = 10; // 00000000 00000000 00000000 00001010 
		                         // 왜 32칸 이냐면 int가 4byte니까 1byte는 8비트
		                         // 노트에는 4칸밖에 안해놈 실수로
		int b;
		b = a <<1; 
		//a를 왼쪽으로 1칸 이동한다는 뜻
		System.out.println("b = " + b);
		// b = (귀찮으니까 8비트만 ) 0001 0100 계산은 2의 3승하고 2의 5승만 있으니까 +하면 20이 나옴
		b = a <<4;
		System.out.println("b = " + b);
		// 그 후 부턴 2배씩 늘어난다고 보면 됨 4칸 이동하면 1칸에 2배씩 이니까 16배?
		// 2배의 n승 느낌 2배하고 2배하고 거기에 또 2배해서 16배까지 뛴거임
		
		b = a >>1;
		System.out.println("b = " + b);
		// 얘는 반대로 2배씩 줄어든다고 보면 됨 a가 10이니까 나누기 2하면 몇? 5가 되니까 0000 0101이 됨
		b = a >>2;
		System.out.println("b = " + b);
		// 또 줄어들어서 2가 됨 몫이 나오는 거 나머지는 안나옴 2로 나누면 2가 나오지요
		
		b = a >>>1;
		// 얘는 좀 까다로움 부호 무시하고 이동하라는 소리인데 부호가 0하고 1이 있음
		// 0은 플러스라는 거고 1은 마이너스라는 뜻임
		// 이거 할 때 맨 앞에 부호가 붙어있는데 저기 위에 10도 맨 앞에 따로 0이 붙음
		// 0 0000~00001010 이런식으로 나머지는 귀찮으니 생략했다 치고 맨 앞에 0 아니면 1이 붙음
		System.out.println("b = " + b);
		// 자 여기서 a 앞에 -가 붙으면 답이 겁나 크게 나옵니다.
		// a가 10이고 -가 붙으면 -10이죠? 그걸 비트로 바꾸면? 몇이니.. 반대로 생각하면 되지요!
		// 쉽게 1로 계산을 해보면 됨
		// 양수를 음수로 계산 하는 건 3가지 방법이 있는데 절대값, 1의보수 , 2의 보수가 있음
		// 절대값은 맨 왼쪽 값이 1이냐 0이냐에 따라서 +,-로 바뀌고 비트 값은 양수 음수 똑같다
		// 1의 보수는 8비트의 경우 최대 크기에 - x를 해주면 됨 최대 크기는 1111 1111이니까
		// -1을 만들고 싶으니까 1111 1111 - x에  비트값 1 / 0000 0001을 대입
		// 하면 앞에 1을 붙이고 1 1111 1110이 됨 1의 정수는 같으면 0 다르면 1로 생각하면 될듯
		// 2의 정수는 제일 많이 쓰는 방법으로 같으면 1 다르면 0으로 생각하면 됨
		// 그리고 얘는 1 0000 0000 - x 형식임 
		// 대입하면 1 1111 1110으로 똑같이 나옴
		
	}

}
